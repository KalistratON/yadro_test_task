Описание алгоритма

1. На вход принимается путь_до_входного_файла, путь_до_выходного_файла, объем_RAM_который_можно_затратить_на_хранение_элементов_из_ленты, кол-во_временных_лент (должно быть K>2)
2. Среди временных лент выделяем одну, в которую будет мержится результат
3. Последовательно в RAM считываются числа из входного файла, далее сортируются. Получаем отсортированный массив в RAM
4. записываем его во временную ленту
5. если есть ещё ленты, то возвращаемся на шаг 3
6. повторяем шаг 3, шаги 4-5 не проходим. Итого у нас есть отсортированные ленты в количестве K-1 и отсортированные массив в RAM
7. далее мержим временные ленты в отдельную (выделенную) временную ленту. Получаем отсортированную ленту из K <= N элементов.
8. Если во входной ленте остались элементы, возвращаемся на шаг 2, на этот раз выделяем другую ленту. Во время работы алгоритма мы поочередно меняем выделенные ленты (напиример tape[0] и tape[1])
9. В зависимости от количества пройденных итераций, для копирования окончательно смержинной ленты в выходную ленту, может понадобится сделать перемотку ленты.
10. Мержим в выходную_ленту

Замечания
1. Для юнит-тестов использовался google tests
2. Для более удобной работы с файлами, перемещения по нему и тд использовался си-шный способ работы с файлами
